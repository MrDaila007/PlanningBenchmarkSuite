# Техническое задание: Planning Benchmark Suite

**Версия:** 1.0  
**Дата:** 2025-02-21  
**Источник:** TASK.md (Техническая спецификация)

---

# 1. Общее описание

## 1.1 Цель разработки

Создать высокопроизводительный C++ фреймворк для реализации и сравнения алгоритмов планирования движения, генерации параметризуемых сред, автоматизированного бенчмаркинга, статистического анализа и воспроизводимых экспериментов с визуализацией результатов.

## 1.2 Связь с контекстом

Проект создаётся с нуля как research-платформа уровня магистерской диссертации и публикации. Соответствует стандартам research-software.

## 1.3 Ключевые стейкхолдеры

- Исследователь (магистр/PhD) — основная аудитория
- Разработчик алгоритмов — добавляет и сравнивает планировщики
- Автор экспериментов — конфигурирует и запускает бенчмарки

---

# 2. Список юзер-кейсов

## UC-01: Запуск планировщика на grid-карте

**Актёры:**
- Исследователь
- Система (Planning Benchmark Suite)

**Предусловия:**
- Установлен фреймворк
- Имеется grid-окружение (occupancy grid)
- Заданы start и goal

**Основной сценарий:**
1. Исследователь выбирает grid-based планировщик (Dijkstra, A*, Weighted A*, Theta*)
2. Исследователь загружает окружение (2D grid)
3. Исследователь указывает start и goal
4. Система выполняет решение через `IPlanner::solve(Environment, start, goal)`
5. Система возвращает путь (Path) или сообщение о неудаче
6. Исследователь получает результат (путь, время, число expansions)

**Альтернативные сценарии:**

**А1: Путь не найден (на шаге 4)**
1. Система возвращает пустой/невалидный Path
2. Система логирует причину (нет пути, timeout и т.д.)
3. Конец

**А2: Некорректные start/goal (на шаге 3)**
1. Система проверяет допустимость start и goal (в пределах карты, не в препятствии)
2. При невалидности — возвращает ошибку до вызова solve
3. Конец

**Постусловия:**
- Возвращён Path или явное сообщение о неудаче
- Зафиксированы метрики: время, nodes expanded

**Критерии приёмки:**
- ✅ Реализован единый интерфейс IPlanner с методом solve
- ✅ Grid-планировщики: Dijkstra, A*, Weighted A*, Theta*
- ✅ Поддержка occupancy grid
- ✅ Подсчёт nodes expanded
- ✅ Min-heap для графовых алгоритмов
- ✅ 100×100 grid A* < 50 ms

---

## UC-02: Запуск sampling-based планировщика в непрерывной среде

**Актёры:**
- Исследователь
- Система

**Предусловия:**
- Установлен фреймворк
- Имеется continuous 2D (или SE(2)) окружение
- Заданы start и goal

**Основной сценарий:**
1. Исследователь выбирает sampling-based планировщик (PRM, Lazy PRM, RRT, RRT*, Informed RRT*)
2. Исследователь загружает continuous окружение
3. Исследователь задаёт параметры (step size, goal bias, iteration budget)
4. Система выполняет solve
5. Система возвращает Path или сообщение о неудаче
6. Исследователь получает результат с метриками

**Альтернативные сценарии:**

**А1: Достигнут лимит итераций без нахождения пути**
1. Система возвращает best-effort путь (если есть) или пустой Path
2. Система фиксирует success=false

**А2: RRT* — отслеживание сходимости**
1. Система ведёт cost vs iteration, gap to optimal
2. Поддержка log convergence rate

**Постусловия:**
- Path или явная неудача
- Метрики: время, nodes, (для RRT*) convergence data

**Критерии приёмки:**
- ✅ Sampling-based: PRM, Lazy PRM, RRT, RRT*, Informed RRT*
- ✅ KD-tree для nearest neighbor
- ✅ Rewiring для RRT*
- ✅ Configurable step size, goal bias
- ✅ RRT* 5000 iter < 500 ms
- ✅ Convergence tracking для RRT*

---

## UC-03: Генерация параметризуемой карты (Map Generator)

**Актёры:**
- Исследователь
- Система

**Предусловия:**
- Фреймворк установлен

**Основной сценарий:**
1. Исследователь задаёт параметры: size, obstacle density, narrow passage width, clustering factor, seed
2. Исследователь выбирает тип генерации (Random uniform, Perlin noise, Maze, Narrow passage benchmark, Random convex polygons)
3. Система генерирует карту детерминированно при заданном seed
4. Система сериализует карту в JSON
5. Исследователь получает файл/объект окружения

**Альтернативные сценарии:**

**А1: Некорректные параметры**
1. Система валидирует параметры (density 0–1, size > 0 и т.д.)
2. При ошибке — возвращает сообщение о некорректном параметре
3. Конец

**Постусловия:**
- Детерминированная карта при одинаковом seed
- Карта сериализуема в JSON

**Критерии приёмки:**
- ✅ Детерминированность при фиксированном seed
- ✅ JSON-сериализация
- ✅ Параметры: size, obstacle density, narrow passage, clustering, seed
- ✅ Типы: Random uniform, Perlin, Maze, Narrow passage, Random convex polygons

---

## UC-04: Collision checking (Grid и Continuous)

**Актёры:**
- Система (используется планировщиками)
- Окружение (Environment)

**Предусловия:**
- Загружено окружение

**Основной сценарий (Grid):**
1. Система проверяет occupancy точки/ячейки
2. Система проверяет линию (Bresenham) на пересечение с препятствиями
3. Результат: collision-free или collision

**Основной сценарий (Continuous):**
1. Система проверяет сегмент–полигон
2. Система вычисляет clearance (минимальная дистанция до препятствий)
3. Результат: collision-free/clearance value

**Критерии приёмки:**
- ✅ Grid: occupancy check, Bresenham line
- ✅ Continuous: segment–polygon, clearance computation

---

## UC-05: Сбор метрик планирования

**Актёры:**
- Система (автоматически при solve)
- Исследователь (читает метрики)

**Предусловия:**
- Выполнен solve планировщика

**Основной сценарий:**
1. Система собирает обязательные метрики: path length, computation time (ms), nodes expanded, success rate, memory usage
2. Система собирает дополнительные: smoothness, clearance, energy functional, RRT* convergence
3. Исследователь получает метрики вместе с Path или отдельно

**Критерии приёмки:**
- ✅ Path length, computation time (ms), nodes expanded, success rate, memory
- ✅ Smoothness: S = Σ|θ_i − θ_{i−1}|
- ✅ Clearance: минимальная дистанция до препятствий
- ✅ Energy: E = ∫κ² ds
- ✅ RRT*: cost vs iteration, gap to optimal, log convergence rate

---

## UC-06: Пакетный запуск бенчмарков (Benchmark Engine)

**Актёры:**
- Исследователь
- Система (CLI benchmark)

**Предусловия:**
- Есть конфиг benchmark (JSON)
- Конфиг содержит: окружения, планировщики, параметры, число повторений

**Основной сценарий:**
1. Исследователь формирует config.json
2. Исследователь запускает `./benchmark --config config.json`
3. Система выполняет batch-запуски (30+ повторов на конфигурацию)
4. Система параллелизует эксперименты (где применимо)
5. Система считает mean, std, confidence intervals
6. Система экспортирует результаты в CSV и JSON
7. Исследователь получает файлы с результатами

**Альтернативные сценарии:**

**А1: Ошибка в config**
1. Система валидирует config
2. При ошибке — выводит сообщение и завершается с ненулевым кодом

**А2: Прерывание (Ctrl+C)**
1. Система корректно сохраняет уже выполненные результаты
2. Конец

**Постусловия:**
- CSV и JSON с результатами
- 100 экспериментов < 1 мин (parallel)

**Критерии приёмки:**
- ✅ CLI: `./benchmark --config config.json`
- ✅ Batch-запуск, 30+ повторов
- ✅ mean, std, confidence intervals
- ✅ Экспорт CSV, JSON
- ✅ Параллельные эксперименты
- ✅ 100 экспериментов (100 пар окружение+планировщик, по 30+ повторов) < 1 мин при параллельном запуске на 4+ ядрах

---

## UC-07: Репродукция экспериментов (Reproducibility)

**Актёры:**
- Исследователь
- Система

**Предусловия:**
- Есть сохранённая конфигурация и seed

**Основной сценарий:**
1. Исследователь загружает сохранённую конфигурацию (JSON)
2. Исследователь указывает seed (или использует из конфига)
3. Система воспроизводит эксперимент с тем же seed
4. Исследователь получает статистически согласованные результаты (при одинаковом seed — детерминированно идентичные; при численных метриках — в пределах машинной точности)

**Критерии приёмки:**
- ✅ Фиксированные seeds
- ✅ Сохранение конфигураций
- ✅ Docker-образ для воспроизведения
- ✅ CI performance regression
- ✅ Автоматическое сравнение коммитов

---

## UC-08: Визуализация результатов

**Актёры:**
- Исследователь
- Система (визуализатор / экспорт для Python)

**Предусловия:**
- Есть результаты экспериментов (CSV/JSON)

**Основной сценарий:**
1. Исследователь загружает результаты
2. Исследователь выбирает тип визуализации: boxplots, convergence curves, heatmaps и т.д.
3. Система строит графики (через Python API / pybind11 или standalone)
4. Исследователь экспортирует изображения или интерактивные графики

**Критерии приёмки:**
- ✅ pybind11 Python API для анализа
- ✅ Поддержка boxplots, convergence curves
- ✅ Экспорт в изображения

---

## UC-09: Статистический анализ (Research Level)

**Актёры:**
- Исследователь
- Система

**Предусловия:**
- Есть результаты бенчмарков

**Основной сценарий:**
1. Исследователь загружает данные
2. Исследователь выполняет t-test, ANOVA, effect size
3. Система возвращает статистические выводы
4. Поддержка контролируемых переменных: map size, obstacle density, narrow passage, dimension, iteration budget

**Критерии приёмки:**
- ✅ t-test, ANOVA, effect size
- ✅ Boxplots, convergence curves
- ✅ Контролируемые переменные

---

## UC-10: Тестирование и CI

**Актёры:**
- Разработчик / CI
- Система

**Предусловия:**
- Код в репозитории

**Основной сценарий:**
1. Разработчик запускает unit tests, property-based, regression, performance tests
2. CI автоматически прогоняет тесты при push/PR
3. Coverage ≥ 80%
4. Performance regression отслеживается

**Критерии приёмки:**
- ✅ Unit, property-based, regression, performance tests
- ✅ Coverage ≥ 80%
- ✅ CI с performance regression

---

## UC-11: Поддержка пространств SE(2) и опционально SE(3)

**Актёры:**
- Исследователь
- Система

**Предусловия:**
- Планировщик поддерживает соответствующее пространство

**Основной сценарий:**
1. Исследователь выбирает окружение SE(2) (позиция + ориентация)
2. Исследователь задаёт start и goal в SE(2)
3. Система выполняет планирование с учётом ориентации
4. Опционально: SE(3) для 3D

**Критерии приёмки:**
- ✅ Поддержка SE(2)
- ✅ Опциональная поддержка SE(3)

---

# 3. Нефункциональные требования

## 3.1 Производительность

- 100×100 grid A* < 50 ms
- RRT* 5000 iter < 500 ms
- 100 экспериментов < 1 мин (parallel)

## 3.2 Технологический стек

- C++20, CMake, Conan/vcpkg
- Eigen, Boost, CGAL, Google Test, nlohmann/json, pybind11
- Опционально: OpenMP/TBB, nanoflann

## 3.3 Архитектура

- Clean Architecture, SOLID
- Разделение domain / infrastructure
- Compile-time polymorphism (templates)
- Zero-overhead abstraction
- Reproducibility-first design

## 3.4 Документация

- Архитектурная диаграмма
- Doxygen
- README с результатами
- Примеры конфигов
- Репликация экспериментов

---

# 4. Ограничения и допущения

- Ориентация на research-сообщество (магистры, PhD)
- Приоритет воспроизводимости над максимальной скоростью
- Допущение: CGAL достаточен для geometry/collision в continuous
- Допущение: nanoflann или аналог — для KD-tree
- Допущение: Conan или vcpkg — для зависимостей (на выбор)

---

# 5. Открытые вопросы

1. **Зависимости:** Предпочтение Conan или vcpkg для управления зависимостями?
2. **Параллелизация:** Обязателен ли OpenMP/TBB в первой версии или опционально?
3. **SE(3):** Включать ли SE(3) в MVP или отложить на следующую итерацию?
4. **Визуализация:** Встроенная (C++) или только через Python/pybind11?
5. **Теоретический анализ:** Нужен ли отдельный документ с асимптотикой и теорией RRT*/A* в рамках этого ТЗ?
